## 7 컨피그맵과 시크릿: 애플리케이션 설정
### 7.1. 컨테이너화된 애플리케이션 설정
 - 쿠버안에 실행되는 애플리케이션에 설정 데이터 전달 방법
 - 그전에 컨테이너화 된 앱이 어떻게 구성되는지 살펴보자
 - 일반적으로 명령줄 인수로 설정 넘김가능 설정할 옵션 목록이 커지면 설정을 파일에 저장하고 사용 할 수 있다.
 - 설정데이터를 저장하는 쿠버네티스 리소스를 컨피그 맵 이라고한다.
 - 컨피그 맵을 사용해 설정데이터를 저장할지 여부에 관계 없이 다음 방법을 통해 에플리케이션을 구성할 수 있다.
    - 컨테이너에 명령줄 인수 전달
    - 각 컨테이너를 위한 사용자 정의 환경변수 지정
    - 특수한 유형의 볼륨을 통해 설정 파일은 컨테이너에 마운트
 - 보안정보 취급을위해 쿠버네티스는 시크릿이라는 중요한 오브젝트를 제공한다

### 7.2. 컨테이너에 명령줄 인자 전달
 - 쿠버는 파드 컨테이너 정의에 지정된 실행 명령대신 다른 실행파일을 실행하거나 다른 명령줄 인자를 사용해 실행하는 것이 가능하다
#### 7.2.1 도커에서 명령어와 인자정의
 - ENTRYPOINT는 컨테이너가 시작될때 호출될 명령어를 정의한다
 - CMD는 ENTRYPOINT에 전달된 인자를 정의한다

```
  docker run <image> # 아무런 인자 지정않고 이미지 - CMD 물고 실행
  docker run <image> <arguments> # CMD에 정의된 값 재지정
```

#### 7.2.2. 쿠버네티스에서 명령과 인자 재정의
 - 컨테이너 정의시 ENTRYPOINT와 CMD 둘 다 재정의할 수 있다.

### 7.3 컨테이너의 환경변수 설정
 - 각 컨테이너를 위한 환경변수 리스트를 지정 할 수 있다.
 - 파드 수준에서 환경변수를 설저아고 컨테이너에서 상속받는것도 유용하지만 지금은 이러한 옵션이없다.

#### 7.3.1. 컨테이너 정의에 환경변수 지정
 - 환경변수는 파드레벨이아닌 컨테이너 정의안에 설정한다.
 
#### 7.3.2. 변수값에서 다른 환경변수 참조
 - $(var) 구문을 사용해 이미 정의된 환경변수나 기타 기존변수를 참조할 수도 있다.

#### 7.3.3 하드코딩된 환경변수의 단점
 - 하드코딩 됐을경우 프로덕션과 개발을 위해 서로 분리된 파드가 필요하다는 의미
 
### 7.4 컨피그맵으로 설정 분리
 - 자주 변경되는 설정옵션을 애플리케이션 소스코드와 별도로 유지하는 것이다.
 - 만약 파드의 정의를 APP의 소스코드로 생각한다면 (MSA안에서 파드정의가 실제로 그러하다.) 설정을 파드 정의에서 밖으로 이동시켜야함

#### 7.4.1 컨피그맵 소개
 - 설접옵션을 컨피그맵이라 부르는 별도 오브젝트로 분리 할 수 있다.
 - 컨피그맵은 짧은 문자열에서 전체 설정파일에 이르는 값을 가지는 키/값 쌍으로 구성된 맵이다.
 - APP은 필요한 경우 쿠버네티스 REST API 엔드포인트를 통해 컨피그맵의 내용을 직접 읽을 수 있지만, 애플리케이션은 쿠버와 무관하도록 유지해야한다.
 - 컨피그맵에 관한 여러 매니페스트를 유지할 수 있다. 파드는 컨피그맵을 이름으로 참조하기 때문에, 모든환경에 동일한 파드 정의를 사용해 환경에서 서로다른 설정을 사용 할 수있다.

#### 7.4.2. 컨피그맵 생성
 - 다음과 같은 명령으로 configmap을 사용 할 수있다
```
   kubectl create configmap 
```
``` 
   kubectl create -f fortune-config.yaml
```

#### 디렉터리에 있는 파일로 컨피그맵 생성
```
   kubectl create configmap my-config --from-file=/path/to/dir
```
#### 다양한 옵션 결함
 - 컨피그맵을 생성할때 지금까지 언급한 모든 옵션을 조합해 사용 할 수 있다.
``` 
   kubectl create configmap my-config
   touch my-config
   --form-file=foo.json
   --from-file=bar=foobar.conf
   --from-file=config-opts/
   --from-literal=some=thing
```

#### 7.4.3 컨피그맵 항목을 환경변수로 컨테이너에 전달
 - 파드로 컨테이너로 전다하는 방법은 세가지 옵션이 있다.
 - 가장 간단한 환경변수를 설정하는 것부터 시작하자, 이를위해 valueFrom 필드를 사용한다.
 
#### 파드에 존재하지 않는 컨피그맵 참조
 - 존재하지 않는 컨피그맵을 참조하려고하면 컨테이너는 시작하는데 실패한다, 하지만 참조안하는 다른 컨테이너는 정상적으로 ㅣ작
 - 그다음 누락된 컨피그맵을 생성하면 팟을 다시만들지 않아도 재시작
 - 컨피그맵을 참조옵션으로하면 컨패그맵이 존재하지않아도 컨테이너 시작됨

#### 7.4.4 컨피그맵의 모든 항목을 한 번에 환경변수로 전달.
 - 컨피그맵에 여러항목이 포함되어있을때 그것을 다 환경변수로 노출하면 오류가 발생하기 쉽다. 1.6V부터는 모든 항목을 환경변수로 노출하는 방법을 제공한다.
 - foo,bar,foo-bar 세 개의 키를 갖고있는 컨피그맵을 생각해보자, env 속성 대신 envFrom 속성을 사용해 환경변수를 모두 노출할 수 있다.
 - config_foo-bar는 대시를 가지고 이어서 올바른 환경변수 이름이 아니다, 쿠버에서 키로 변환하지 않는다.

#### 7.4.5 컨피그맵 항목을 명령줄 인자로 전달
 - 컨피그맵 값을 컨테이너 안에서 실행되는 프로세스의 인자로 전달하는 방법을 알아보자
 - pod.spec.containers.args 필드에서 컨피그맵 항목을 환경변수로 먼저 초기화하고, 인자로 참조되도록 지정 할 수있다.

#### 7.4.6. 컨피그맵 볼륨을 사용해 컨피그맵 항목을 파일로 노출
 - 앞에서 본 것처럼 컨피그맵은 모든 설정파일을 포함할 수 있다.
 - 이 파일들을 컨테이너에 노출시키려면 6장에서 나온 특수볼륨중 하나인 컨피그맵 볼륨을 사용 할 수있다.
 - 컨테이너에서 실행 중인 프로세스는 이 파일 내용을 읽어 각 항목의 값을 얻을 수 있다.
 - 대형 설정파일들을 컨테이너에 전달하기 위한 방법이지만, 짧은 단일값을 전달할 때도 문제없다.

#### 컨피그맵 생성
 - Nginx 서버가 응답을 압축해서 보내려고 한다고 가정해보자. my-nginx-config.conf 처럼 작업했다
 - 기존 configmap 을 삭제하고 nginx 설정하는 컨피그맵으로 교체 할 수 있다.
```
kubectl create configmap fortune-config --from-file=configmap-files 
```
 - 위와같은 명령어를 활용해 파일로부터 컨피그맵을 생성 할 수 있다.

#### nginx 서버가 마운트한 설정파일을 사용하는 지 확인
 - 이제 웹서버는 응답을 압축해서 보내주도록 설정되어 있어야한다
 - 검증하려면 curl 명령을 이용해 서버응답을 확인 가능하다.

#### 볼륨에 특정 컨피그맵 항목 노출
 - sleep-interval 항목은 볼륨이 아닌 환경변수로 전달해 fortuneloop 컨테이너에 영향을 주지 안흔다
 - 컨피그맵 볼륨 안에 파일로 노출될 항목을 정의하려면 items 속성을 사용한다

#### 디렉터리를 마운트할 때 디렉터리의 기존 파일을 숨기는 것 이해
 - 볼륨을 디렉터리에 마운트 했다는 것은 이미지 자체에 있던 /etc/nginx/conf.d 디렉터리 안에 저장된 파일을 숨겼음을 의미
 - 원래 있던 파일은 해당 파일시스템이 마운트돼 있는 동안 접근할 수 없게 된다.
 - 만약 /etc 디렉터리에 볼륨을 마운트 한다고 하자, /etc 디렉터리에 있어야 하는 모든 원본파일이 더이상 존재하지 않기 때문에, 전체 컨테이너가 손상될 수 있다.

#### 디렉터리 안에 다른 파일을 숨기지 않고 개별 컨피그맵 항목을 파일로 마운트
 - 전체 볼륨을 마운트 하는 대신 volumeMount에 subPath 속성으로 파일이나 디렉터리 하나를 볼륨에 마운트할 수 있다.

#### 컨피그맵 볼륨 안에 있는 파일 권한 설정
 - 기본적으로 컨피그맵 볼륨의 모든 파일 권한은 644(-rw-r-r--) (owner rw, group other r) 이다.
 - 필요하다면 defaultMode 속성을 성정해 변경할 수 있다.


#### 7.4.7 애플리케이션으 재시작하지 않고 애플리케이션 설정 업데이트
 - 환경변수 or 명령줄 인수를 소스로 할때 단점은 프로세스가 실행되고있는 동안에 업데이트 불가능, 컨피그맵을 사용하면 업데이특나ㅡㅇ
 - 컨피그맵을 업데이트 하고난 후 파일이 업데이트 되는건 오래걸릴 수도 있다

#### 컨피그맵 편집
```
 kubectl edit configmap fortune-config
```

#### 설정다시로드하기 위해 nginx에 신호전달
```
kubectl exec fortune-configmap-volume -c webserver -- nginx -s reload
```


#### 7.5.2. 기본 토큰 시크릿 소개
 - 모든 파드에는 시크릿 볼륨이 자동으로 연결돼 있다.

#### 7.5.3 시크릿 생성
 - 
``` 
openssl genrsa -out hhtps.key 2048  
openssl req -new -x509 -key https.key -out https.cert -days 3650 -subj
echo bar > foo     
kubectl create secret generic fortune-https --from-file=hhtps.key     
```

 - z컨피그맵을 생성하는것과 크게 다르지않다.
 - 여기에서 fortune-https 이름을 가진 generic을 시크릿을 생성했다
   (시크릿에는 도커 레지스트리를 사용하기위한 docker-registry, tls를 위한 tls, generic이 있다.)
   
#### 7.5.4 컨피그맵과 시크릿비교
 - 시크릿과 컨피그맵은 매우 큰 차이가 있다. 쿠버개발자들이 시크릿을 지원하다가 컨피그맵을 생성하게 한 이유다.
``` 
kubectl get secrets fortune-https -o yaml
```
 - 시크릿항목의 내용은 base64로 인코딩 문자열로 표시되고, 컨피그맵은 일반 텍스트로 표시된다.

####  바이너리 데이터 시크릿 사용
 - base64 인코딩을 사용하는 까닭은 간단하다, 일반텍스트 뿐만아니라 바이너리값도 담을 수 있기때문
 - base64 인코딩은 바이너리 데이터를 일반텍스트형식인 yaml이나 json에 넣을 수 있다.

#### stringData 소개
 - 모든 민감한 데이터가 바이너리가 아니기때문에 stringData 필드로 설정할 수 있게해준다
 - StringData필드는 쓰기 전용이다.
```
kubectl create secret generic tmpuser --from-literal=username=admin --from-literal=password=1234qwert 
```
#### 7.5.5 파드에서 시크릿 사용
 - 인증서와 키 파일을 모두 포함하는 fortune-https 시크릿을 nginx에서 사용할 수 있도록 설정하는 것필요
#### https를 활성화 하도록 fortune-config 컨피그맵 수정
