##5 서비스: 클라이언트가 파드를 검색하고 통신을 가능하게 함
 - 쿠버네티스가 아닌 세계에선 sys관리자가 클라이언트 구성파일에 제공하는 서버의 IP주소나 호스트이름을 지정해 각 클라이언트 애플리케이션을 구성하는 거과 달리, 쿠버에선 이렇게 하면 동작안함
    - 파드는 일시적이다. 파드는 제거되거나, 파드수를 줄이거나, 언제든 다른노드로 이동가능
    - 쿠버는 노드에 파드를 스케줄링 후 파드가 시작 직전에 IP 할당, 미리 아이피 모름
    - 수평스케일은 여러파드가 동일한 서비스 제공의미, 클라는 서비스를 지원하는 파드수와 IP에 상관 x 파드의 개별 IP목록 유지 필요없음. 그대신 모든 파드는 단일 IP로 접근가능해야함
    
#### 5.1. 서비스 소개
 - 쿠버 서비스란 동일한 서비스를 제공하는 파드그룹에 단일 접점을 만들때 생성하는 리소스 서비스가 존재하는동안 절대 바뀌지않는 IP와 포트
 - 클라는 해당 IP와 포트로 접속 후, 해당 서비스를 지원하는 파드중 하나로 연결된다.
 - 서비스의 존재로인해 파드의 위치를 알필요가 없으므로 클러스터 안에서 이동가능.

#### 예제를 통한 서비스 설명
 - 프론트엔드 파드는 여러개 있을수 있지만, 백엔드 db파드는 하나만 있을것이다.
 - 시스템이 기동하려면 두 가지 문제를 해결 해야한다
    - 웹 서버가 수백개든 상관없이 외부 클라는 파드에 연결 가능해야한다
    - 프론트엔드 파드는 백 DB파드에 연결해야한다. DB는 파드내에서 실행되므로 시간이 지남에 따라 IP변경가능
 - FE 파드에 관한 서비스를 만들고 클라가 연결할수 있는 고정아이피 주소가 노출
 - 이와같이 백엔드도 서비스를 만들어 IP 가져옴
 - 프론트엔드 파드에서는 환경변수 또는 DNS 이름으로 백엔드서비스를 쉽게 찾을 수 있다.

##### 5.1.1. 서비스 생성
 - 서비스 연결은 서비스 뒷단의 모든 파드로 로드밸런싱 된다.
 - 정확히 어떤 파드가 서비스의 일부분인지 어떻게 정의?
 - 레이블 셀렉터를 기억할것이며 RC를 통해 동일한 세트속에 속한 파드를 지정하는 방법을 알것이다.
 - 동일한 매커니즘이 그대로 사용된다.

##### kubectl expose로 서비스 생성
 - 서비스 생성 가장 쉬운방법 = kubectl expose 사용
 -
```
kubctl get svc 
```

#### 클러스터 내에서 서비스 테스트
 - 몇가지방법으로 클러스터 내에서 서비스로 요청보낼 수 있다.
    - 클러스터 IP로 요청을 보내고, 응답을 로그로 남가는 파드를 만드는 것, 그런다음 파드의 로그를 검사해 서비스의 응답 확인
    - 쿠버네티스 노드로 ssh접속을 하고  curl 명령을 실행할 수 있다.
    - kubectl exec 명령어로 기존 파드에서 curl을 보낼 수 있다.
   
#### 실행중 컨테이너에 원격으로 명령어 실행
 - kubectl exec 명령어로 기존파드 컨테이너 내에서 원격으로 명령어 실행가능,
 - kubectl get pods 로 pods를 조회하고 , exec 명령어의 대상으로 하나를 선택해야함.
 - 또한 클러스터의 IP를 알아야한다.

```
kubectl exec kubia-7nog1 -- curl -s http:10.1231
command terminated with exit code 6
-> rc를 생성하니까 됨, rset은 안됨 ??;; -> 컨테이너의 포트와 서비스 엑세스포트, rc의 포트를 안맞춰주니
# 포트포와딩
kubectl port-forward service/redis-master 7000:redis
```

#### 서비스의 세션 어피니티 구성
 - 요청할때마다 다른 파드가 설정된다.
 - 특정클라이언트의 요청을 매번 같은파드로 갈려면 세션어피니티 속성을 기본값 대신 clientIp로 설정한다.
 - 쿠키 기반의 세션어피니티는 옵션이없다. 서비스는 TCP/UDP 패킷을 처리하고, 페이로드는 신경쓰지않는다.
 - 쿠키는 HTTP 프 로토콜의 구성이기때문에 서비스는 쿠키를 알 수 없다.

#### 동일한 서비스에서 여러개의 포트 노출
 - 포트스라는 옵션을통해 여러 포트로 노출시킬수있다.

#### 이름이 지정된 포트 사용
 - 지금까지는 대상 파드의 포트번호를 참조했지만, 각파드 포트에 이름을 지정하고, 서비스스펙에서 이름참조가능
 - 이렇게하면 포트이름을 변경하지 않고 파드스펙에서 포트번호를 변경하기만 하면된다.

#### 서비스 검색
 - 서비스를 만들면 파드에 액세스할수있는 안정적인 IP가 생긴다.
 - 클라이언트 파드는 서비스의 IP와 포트를 어떻게 알까?
 - 쿠버에서 클라잉너트 파드가 서비스의 IP와 포트를 검색할수 있는 방법을 제공한다.

#### 환경변수를 통한 서비스 검색
 - 파드를 만든후에 서비스를 만들면 서비스에 대한 환경변수를 설정할 수 없다.
 - backend-database라는 서비스로 백엔드 파드를 노출하면, 환경변수 BACKEND_DATABASE_SERVICE_HOST와 BACKEND_DATABASE_SERVICE_PORT로 서비스의 IP주소와 포트찾을수 있다.

#### DNS를 통한 서비스 검색
 - kube-dns와 kube-system 네임스페이스에는 동일한 이름의 해당 서비스가 있다.
 - 이름에서 알수있든 이 파드는 dns 서버를 실행하며, 실행중인 다른 모든 파드는 자동으로 이를 사용하도록 구성된다.
 - 파드에서 실행중인 프로세스에서 수행된 모든 DNS 쿼리는 시스템에서 실행 중인 모든 서비스를 알고있는 쿠버자체의 DNS서버로 처리된다.
 - 내부 DNS 사용여부는 dnsPolicy 속성으로 구성할수 있다.
 -클라이언트 파드는 환경변수 대신 FQDN(정규화된 도메인이름) 으로 엑세스 할 수 있다.
   

#### FQDN을 이욜한 서비스 연결
 - 프론트엔드 파드는 다음 FQDN으로 백엔드 데이터베이스 서비스에 연결할 수 있다.
```
   backend-database.default.svc.cluster.local
```
 - 서비스이름, 네이므페이스, svc.cluster.local은 모든 클러스터의 로컬 서비스 이름에 사용되는 클러스터의 도메인 접미사다
 - 서비스에 연결하는 것은 훨씬 간단하다.

#### 파드의 컨테이너 내에서 셀 실행
```
   kubectl exec -it kubia-3inly bash
   cat /etc/resolv.conf
```
 - 컨테이너 내부의 DNS resolver가 구성돼 있기때문에, 접미사 생략가능

#### 서비스 IP에 핑을 할 수 없는 이유
 - 서비스로 curl은 동작하지만, 핑은 응답이없다. 서비스의 클러스터 IP가 가상 Ip 이므로 서비스 포트와 결합된 경우에만 의미있다.

#### 5.2 클러스터 외부에 있는 서비스 연결
 - 쿠버 서비스 기능으로 외부 서비스를 노출하려는 경우가 있을 수 있다. 서비스가 클러스터 내에있는 파드로 연결을 전달이 아니라, 외부 IP와 포트를 전달하는것

#### 5.2.1 서비스 엔드포인트 소개
 ``` 
 kubectl describe svc kubia
 ``` 
 - 엔드포인트를 확인 할 수있다.
 - kubectl get endpoints kubia 를 사용해 기본정보를 표시 할 수 있다.

#### 5.2.2 서비스 엔드포인트 수동 구성
 - 서비스 엔드포인트를 서비스와 분리하면 엔드포인트를 수동으로 구성하고 업데이트 할 수 있다.
 - 파드 셀렉터 없이 서비스를 만들면 쿠버는 엔드포인트 리소스를 만들지 못한다.
 - 수동으로 관리되느 ㄴ엔드포인트를 사용해 서비스를 만드려면, 서비스와 엔드포인트 리소스를 모두 만들어야한다.

#### 셀렉터 없이 서비스 생성
 - 서비스에서 셀렉터를 제거하면 쿠버는 엔드포인트 업데이트를 멈춘다.

#### 5.2.3. 외부 서비스를 위한 별칭 생성
 - 좀더 간단한 FQDN으로 외부서비스를 참조할 수 있다. 
   #### ExternalName 서비스 생성
   - type을 externalName으로 설정해 서비스 리소스를 만든다.
   


#### 5.3 외부 클라이언트에 서비스 노출
 - 지금까지는 내부 파드가 서비스를 사용하는 법만 봄
 - 외부서 서비스 엑세스 방법 몇가지
   - 노드포트로 서비스 유형설정: 각 클러스터 노드는 노드 자체에서 포트를 열고 해당 포트로 수신된 트래픽을 서비스로 전달
   - 서비스 유형을 노드포트 유형의 확장인 로드밸런서로 설정: 쿠베가 실행중인 클라우드 인프라에서 프로비저닝된 전용 로드밸런서로 서비스에 액세스가능, 로드밸런서는 트래픽을 모든 노드의 노드포트로 전달. 클라이언트는 로드밸런서의 Ip로 엑세스
   - 단일 IP주소로 여러 서비스를 노출하는 인그레스 리소스 만들기: HTTP레벨에서 작동하므로 4계층서비스보다 더많은 기능제공
   
 - 외부 클라이언트에서 접근가능한 노드포트를 보여준다
```
kubectl get svc kubia-nodeport
```
   - 10.103.117.168:80
   - 첫번째 노드의:30123
   - 두번째 노드의:30123
