##5 서비스: 클라이언트가 파드를 검색하고 통신을 가능하게 함
 - 쿠버네티스가 아닌 세계에선 sys관리자가 클라이언트 구성파일에 제공하는 서버의 IP주소나 호스트이름을 지정해 각 클라이언트 애플리케이션을 구성하는 거과 달리, 쿠버에선 이렇게 하면 동작안함
    - 파드는 일시적이다. 파드는 제거되거나, 파드수를 줄이거나, 언제든 다른노드로 이동가능
    - 쿠버는 노드에 파드를 스케줄링 후 파드가 시작 직전에 IP 할당, 미리 아이피 모름
    - 수평스케일은 여러파드가 동일한 서비스 제공의미, 클라는 서비스를 지원하는 파드수와 IP에 상관 x 파드의 개별 IP목록 유지 필요없음. 그대신 모든 파드는 단일 IP로 접근가능해야함
    
#### 5.1. 서비스 소개
 - 쿠버 서비스란 동일한 서비스를 제공하는 파드그룹에 단일 접점을 만들때 생성하는 리소스 서비스가 존재하는동안 절대 바뀌지않는 IP와 포트
 - 클라는 해당 IP와 포트로 접속 후, 해당 서비스를 지원하는 파드중 하나로 연결된다.
 - 서비스의 존재로인해 파드의 위치를 알필요가 없으므로 클러스터 안에서 이동가능.

#### 예제를 통한 서비스 설명
 - 프론트엔드 파드는 여러개 있을수 있지만, 백엔드 db파드는 하나만 있을것이다.
 - 시스템이 기동하려면 두 가지 문제를 해결 해야한다
    - 웹 서버가 수백개든 상관없이 외부 클라는 파드에 연결 가능해야한다
    - 프론트엔드 파드는 백 DB파드에 연결해야한다. DB는 파드내에서 실행되므로 시간이 지남에 따라 IP변경가능
 - FE 파드에 관한 서비스를 만들고 클라가 연결할수 있는 고정아이피 주소가 노출
 - 이와같이 백엔드도 서비스를 만들어 IP 가져옴
 - 프론트엔드 파드에서는 환경변수 또는 DNS 이름으로 백엔드서비스를 쉽게 찾을 수 있다.

##### 5.1.1. 서비스 생성
 - 서비스 연결은 서비스 뒷단의 모든 파드로 로드밸런싱 된다.
 - 정확히 어떤 파드가 서비스의 일부분인지 어떻게 정의?
 - 레이블 셀렉터를 기억할것이며 RC를 통해 동일한 세트속에 속한 파드를 지정하는 방법을 알것이다.
 - 동일한 매커니즘이 그대로 사용된다.

##### kubectl expose로 서비스 생성
 - 서비스 생성 가장 쉬운방법 = kubectl expose 사용
 -
```
kubctl get svc 
```

#### 클러스터 내에서 서비스 테스트
 - 몇가지방법으로 클러스터 내에서 서비스로 요청보낼 수 있다.
    - 클러스터 IP로 요청을 보내고, 응답을 로그로 남가는 파드를 만드는 것, 그런다음 파드의 로그를 검사해 서비스의 응답 확인
    - 쿠버네티스 노드로 ssh접속을 하고  curl 명령을 실행할 수 있다.
    - kubectl exec 명령어로 기존 파드에서 curl을 보낼 수 있다.
   
#### 실행중 컨테이너에 원격으로 명령어 실행
 - kubectl exec 명령어로 기존파드 컨테이너 내에서 원격으로 명령어 실행가능,
 - kubectl get pods 로 pods를 조회하고 , exec 명령어의 대상으로 하나를 선택해야함.
 - 또한 클러스터의 IP를 알아야한다.

```
kubectl exec kubia-7nog1 -- curl -s http:10.1231
command terminated with exit code 6
-> rc를 생성하니까 됨, rset은 안됨 ??;; -> 컨테이너의 포트와 서비스 엑세스포트, rc의 포트를 안맞춰주니
# 포트포와딩
kubectl port-forward service/redis-master 7000:redis
```

#### 서비스의 세션 어피니티 구성
 - 요청할때마다 다른 파드가 설정된다.
 - 특정클라이언트의 요청을 매번 같은파드로 갈려면 세션어피니티 속성을 기본값 대신 clientIp로 설정한다.
 - 쿠키 기반의 세션어피니티는 옵션이없다. 서비스는 TCP/UDP 패킷을 처리하고, 페이로드는 신경쓰지않는다.
 - 쿠키는 HTTP 프 로토콜의 구성이기때문에 서비스는 쿠키를 알 수 없다.

#### 동일한 서비스에서 여러개의 포트 노출
 - 포트스라는 옵션을통해 여러 포트로 노출시킬수있다.

#### 이름이 지정된 포트 사용
 - 지금까지는 대상 파드의 포트번호를 참조했지만, 각파드 포트에 이름을 지정하고, 서비스스펙에서 이름참조가능
 - 이렇게하면 포트이름을 변경하지 않고 파드스펙에서 포트번호를 변경하기만 하면된다.

#### 서비스 검색
 - 서비스를 만들면 파드에 액세스할수있는 안정적인 IP가 생긴다.
 - 클라이언트 파드는 서비스의 IP와 포트를 어떻게 알까?
 - 쿠버에서 클라잉너트 파드가 서비스의 IP와 포트를 검색할수 있는 방법을 제공한다.

#### 환경변수를 통한 서비스 검색
 - 파드를 만든후에 서비스를 만들면 서비스에 대한 환경변수를 설정할 수 없다.
 - backend-database라는 서비스로 백엔드 파드를 노출하면, 환경변수 BACKEND_DATABASE_SERVICE_HOST와 BACKEND_DATABASE_SERVICE_PORT로 서비스의 IP주소와 포트찾을수 있다.

#### DNS를 통한 서비스 검색
 - kube-dns와 kube-system 네임스페이스에는 동일한 이름의 해당 서비스가 있다.
 - 이름에서 알수있든 이 파드는 dns 서버를 실행하며, 실행중인 다른 모든 파드는 자동으로 이를 사용하도록 구성된다.
 - 파드에서 실행중인 프로세스에서 수행된 모든 DNS 쿼리는 시스템에서 실행 중인 모든 서비스를 알고있는 쿠버자체의 DNS서버로 처리된다.
 - 내부 DNS 사용여부는 dnsPolicy 속성으로 구성할수 있다.
 -클라이언트 파드는 환경변수 대신 FQDN(정규화된 도메인이름) 으로 엑세스 할 수 있다.
   

#### FQDN을 이욜한 서비스 연결
 - 프론트엔드 파드는 다음 FQDN으로 백엔드 데이터베이스 서비스에 연결할 수 있다.
```
   backend-database.default.svc.cluster.local
```
 - 서비스이름, 네이므페이스, svc.cluster.local은 모든 클러스터의 로컬 서비스 이름에 사용되는 클러스터의 도메인 접미사다
 - 서비스에 연결하는 것은 훨씬 간단하다.

#### 파드의 컨테이너 내에서 셀 실행
```
   kubectl exec -it kubia-3inly bash
   cat /etc/resolv.conf
```
 - 컨테이너 내부의 DNS resolver가 구성돼 있기때문에, 접미사 생략가능

#### 서비스 IP에 핑을 할 수 없는 이유
 - 서비스로 curl은 동작하지만, 핑은 응답이없다. 서비스의 클러스터 IP가 가상 Ip 이므로 서비스 포트와 결합된 경우에만 의미있다.

#### 5.2 클러스터 외부에 있는 서비스 연결
 - 쿠버 서비스 기능으로 외부 서비스를 노출하려는 경우가 있을 수 있다. 서비스가 클러스터 내에있는 파드로 연결을 전달이 아니라, 외부 IP와 포트를 전달하는것

#### 5.2.1 서비스 엔드포인트 소개
 ``` 
 kubectl describe svc kubia
 ``` 
 - 엔드포인트를 확인 할 수있다.
 - kubectl get endpoints kubia 를 사용해 기본정보를 표시 할 수 있다.

#### 5.2.2 서비스 엔드포인트 수동 구성
 - 서비스 엔드포인트를 서비스와 분리하면 엔드포인트를 수동으로 구성하고 업데이트 할 수 있다.
 - 파드 셀렉터 없이 서비스를 만들면 쿠버는 엔드포인트 리소스를 만들지 못한다.
 - 수동으로 관리되느 ㄴ엔드포인트를 사용해 서비스를 만드려면, 서비스와 엔드포인트 리소스를 모두 만들어야한다.

#### 셀렉터 없이 서비스 생성
 - 서비스에서 셀렉터를 제거하면 쿠버는 엔드포인트 업데이트를 멈춘다.

#### 5.2.3. 외부 서비스를 위한 별칭 생성
 - 좀더 간단한 FQDN으로 외부서비스를 참조할 수 있다. 
   #### ExternalName 서비스 생성
   - type을 externalName으로 설정해 서비스 리소스를 만든다.
   


#### 5.3 외부 클라이언트에 서비스 노출
 - 지금까지는 내부 파드가 서비스를 사용하는 법만 봄
 - 외부서 서비스 엑세스 방법 몇가지
   - 노드포트로 서비스 유형설정: 각 클러스터 노드는 노드 자체에서 포트를 열고 해당 포트로 수신된 트래픽을 서비스로 전달
   - 서비스 유형을 노드포트 유형의 확장인 로드밸런서로 설정: 쿠베가 실행중인 클라우드 인프라에서 프로비저닝된 전용 로드밸런서로 서비스에 액세스가능, 로드밸런서는 트래픽을 모든 노드의 노드포트로 전달. 클라이언트는 로드밸런서의 Ip로 엑세스
   - 단일 IP주소로 여러 서비스를 노출하는 인그레스 리소스 만들기: HTTP레벨에서 작동하므로 4계층서비스보다 더많은 기능제공
   
 - 외부 클라이언트에서 접근가능한 노드포트를 보여준다
```
kubectl get svc kubia-nodeport
```
   - 10.103.117.168:80
   - 첫번째 노드의:30123
   - 두번째 노드의:30123

#### 5.3.2 외부 로드밸런서로 서비스 노출
 - 일반적으로 클라우드 인프라에서 로드밸런서를 자동으로 프러비저닝 하는 기능을 제공한다.
 - 로드포트를 로드밸런서로만 바꾸면됨.
 - 액세스가능한 고유 Ip를 가지며 모든연결을 서비스로 전달.

   #### 세션 어피니티와 웹 브라우저
   - 브라우저는 매번 정확히 같은 파드를 호출, 그동안 세션 어피니티가 여전히 None으로 설정돼 있음을 확인 할 수 있다.
   - Curl을 사용할때와 같이 브라우저 요청이 다른파드로 가지않을까?
   - 브라우저는 keep-alive 연결을 사용하고, 같은 연결로 모든요청을 보냄, curl은 매번 새로운 여결을 연다.
   - 서비스는 연결 수준에서 동작하므로, 서비스에 대한 연결을 처음열면 임의의 파드가 선택된 다음 해당연결에 속하는 모든 네트워크 패킷은 모두 같은포드로 전송된ㄷ.
   - 세션 어피니티가 논으로 설정돼있어도, 사용자는 항상 동일한 파드에 연결된다.
   
#### 5.3.3 외부 연결의 특성 이해
 - 외부에서 서비스로 들어오는 연결과 관련해 알아둬야 할 몇가지
 #### 불필요한 네트워크 홉의 이해와 예방
 - 외부 클라이언트가 노드포트로 서비스에 접속 할 경우(로드밸런서도 포함) 임의로 선택된 파드가 연결을 수신한 동일한 노드에서 실행중일 수도 잇고, 그렇지 않을 수도 있다.
 - 파드에 도달하려면 추가적인 네트워크 홉이 필요할 수 있으며 이것이 항상 바람직 한 것은아님.
 - 외부의 연결을 수신한 노드에서 실행중인 파드로만 외부 트래픽을 전달하도록 서비스를 구성해 이 추가홉을 방지 할 수 있다.
 - 서비스 스펙에서 externalTrafficPolicy: Local 을 선택함녀된다.
 - 이옵션사용시 만약 로컬파드가 존재하지 않으면 연결이 중단됨
 - 따라서 반드시 로드밸런서는 그러한 파드가 하나이상 있는 노드에만 연결을 전다랗도록 해야한다.
 - 이어노테이션을 사용하면 또다른단점은 파드에 균등하게 요청이 분산되지않음.

 #### 클라이언트 IP가 보존되지 않음 인식
 - 일반적으로 서비스의 파드는 클라이언트 Ip 주소를 알아낼 수있음.
 - 그러나 노드포트로 연결을 수신하면, 패킷에서 소스 네트워크 주소변환(SNAT)가 실행되므로 패킷의 소스 IP가 변경된다.
 - 웹서버에 경우 로그에 브라우저 IP를 표시하지 못함.
 - LocalExternalTrafficPolicy는 연결을 수신하는 노드와 대상파드를 호스팅하는 노드사이에 추가홉이 없기 때문에 클라이언트 IP보존에 영향을 미친다.(SNAT가 수행 X)

#### 5.4 인그레스 리소스로 서비스 외부 노출
 - 외부에서 쿠베로 접속할 수 있는 또다른 방법이다.
 #### 인그레스 리소스가 필요한 이유
  - 로드밸런서 서비스는 자신의 공용 IP주소를 가진 로드밸런서 필요, 인그레ㅔ스는 한 IP 주소로 수십개의 서비스에 접근이가능하도록 지원
  - HTTP 요청을 인그레스에 보낼 때, 요청한 호스트와 경로에 따라 전달하 서비스가 결정된다.
  - 인그레스는 네트워크 스택의 애플리케이션(HTTP) 에서 작동하며, 서비스가 할 수 없는 쿠키기반 세션 어피니티등과 같은 기능을 제공할 수 있다.

 #### 인그레스 컨트롤러가 필요한 경우
  - 인그레스 리소스를 작동시키려면 클러스터에 인그레스 컨트롤러를 실행시켜야함.
  - 쿠버 환경마다 다른컨트롤러 구현을 사용할 수 있지만, 일부는 기본컨트롤러를 제공안함
  - 예로 구글 쿠버엔진은 구글클라우드 플랫폼의 고유한 HTTP 로드밸런싱 기능을 사용해 인그레스 기능을 제공, 미니쿠베는 애드온 제공

```
minikube addons list
minikube addons enable ingress
# 모든 파드 가져오기
kubectl get po --all-namespaces

```


#### 5.4.4 TLS 트래픽을 처리하도록 인그레스 구성
 - 인그레스가 HTTP 전달하는 방법을 봤다. 그럼 HTTPS?
 - TLS를 지ㅝㄴ하도록 인그레스를 구성

  #### 인그레스를 위한 TLS 인증서 생성
   - 클라이언트가 인그레스 컨트롤러에 대한 TLS 연결을 하면, 컨트롤러는 TLS 연결ㅇ르 종료한다.
   - 클라 컨트롤러간 통신은 암호화 되지만, 컨트롤러, 백엔드파드간 통신은 암호화되지 않음.
   - 파드에서 실행중인 애플리케이션은 TLS를 지원할 필요가없다.
   - 예를들어 파드가 웹서버를 실행하는경우 HTTP만 허락하고, 인그레스컨트롤러가 TLS를 처리하게 한다.
   - 그렇게하려면 인증서와 개인키를 인그레스에 첨부한다.
   - 이 두개는 시크릿이라는 쿠버리소스에 저장하며 인그레스 매니페스트에서 참조한다.

```
openssl genrsa -out tls.key 2048
openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj /CN=kubia.example
kubectl create secret tls tls-secret --cert=tls.cert --key-tls
#TIP 지우고 새로 생성할필요없이 applyㄹㄹ 하면 리소스가 업데이트된다
kubectl apply -f kubia-ingress-tls.yaml 
```


#### 5.5 다시 할것

#### 5.6 헤드리스 서비스로 개별 파드 찾기
 - 지금까지 서비스의 연결은 임픠파드로 전달된다. 그러나 클라이언트가 모든파드에 연결할경우?
 - 파드가 다른파드에 각각 연결해야 하는경우는?
 - 서비스로 연결하는건 확실한 방법이아니다. 클라이언트가 모든파드에 연결하려면 각 파드의 IP를 알아야한다.
 - 한가지 옵션은 클라이언트가 쿠버 API 서버를 호출해 IP주소 목록을 가져오도록 하는것이다.
 - 하지만 애플리케이션을 쿠버와 무관하게 유지하려고 노력해야하기때문에, 항상 API서버를 사용하는 것은 바람직X
 - 쿠버는 클라가 DNS 조회로 파드 IP를 찾을수 있도록 한다.
 - `일반적으로 서비스에 대한 DNS조회를 수행하면 DNS서버는 하나의 IP(서비스의 클러스터IP)를 반환, 그러나 쿠버 서비스에 클러스터IP가 필요하지 않다면(서비스 스펙에서 clusterIp 필드를 None으로 설정해 수행하면) DSN서버는 하나의 서비스IP 대신 파드IP들을 반환`
 - DNS 서버는 하나의 DNS A 레코드를 반환하는 대신 서비스에 대한 여러개 A레코드를 반환한다.
 - 각 레코드는 해당시점에서비스를 지원하는 개별파드의 IP 이다.
 - DNS A 레코드 조회를 수행하고, 서비스에 포함된 모든파드의 IP를 얻을 수 있다.
 - 그렇게 클라는 하나 혹은 다수의 또는 모든파드에 연결할수있다.

#### 5.6.2 DNS로 파드 찾기
 - 파드가 준비되면 DNS 조회로 실제 파드 IP를 얻을 수 있는지 확인할 수 있다.
 - 안타깝게도 kubia 컨테이너 이미지에는 nslookup 바이너리가 포함되있지 않으므로 dNS 조회를 수행하는데 사용X
 - 클러스터에서 실행중인 파드 내부에서 DNS 조회를 수행하기만 함녀 된다.
 - dns관련작업을 수행하려면 도커허브의 nslookup 및 dig 바이너리를 모두 포함하는 tutum/dnsutils 컨테이너 이미지를 사용가능

```
   kubectl run dnsutils --image=tutum/dnsutils --generator=run-pod/v1 --command -- sleep infinity
   kubectl exec dnsutils nslookup kubia-headless
```
 - dns 서버는 ~~.local FQDN에 대해 서로다른 두개의 IP를 반환, 준비됐다고 보고된 파드 두개의 아이피이다
 - 일반서비스에 때리면 서비스의 클러스터 ip이다.
 - 헤드리스 서비스는 일반 서비스와 다르게 보일 수 있지만, 클라이언트 관점에서는 다르지 않다.
 - 헤드리스 서비스를 사용하더라도 클라이언트는 일반 서비스와 마찬가지로 서비스의 DNS이름에 연결해 파드에 연결가능
 - 그러나 헤드리스 서비스에서는 DNS가 파드의 IP를 반환하기 때문에 클라이언트는 서비스 프록시 대신 파드에 직접연결한다.
 - 헤드리스 서비스는 여전히 파드간 로드밸런싱을 제공하지만, 서비스 프록시대신 DNS라운드로빈 매커니즘으로 제공
