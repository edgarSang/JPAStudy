#9장 디플로이먼트: 선언적 애플리케이션 업데이트
 - 디플로이먼트는 선언적인 애플리케이션 업데이트를 가능하게 한다.

#### 9.1. 파드에서 실행중인 애플리케이션 업데이트
 - 버전을 업데이트할때 문제점을보자.
 - 이전버전을 삭제하고 새버전을하면 서비스가 중단 될 것이다. 그렇다고 새버전을띄우고 이전버전을 삭제한다면,. 새버전이 이전버전을 손상시킬 수 있는 데이터 스키마나 데이터의 수정을 해선안된다
 - 쿠버에선 이를 어떻게 해결할까

#### 9.1.1. 오래된 파드를 삭제하고 새 파드로 교체
 - 모든 파드의 인스턴스를 새버전의 파드로 교체하기 위해 rc사용하는건 모두 알고 있을 것이다.
 - rc의 파드 템플릿은 언제든지 업데이트 가능 하다.
 - v1파드를 관리하는 rc가 있는 경우 이미지의 버전 v2를 참조하도록 파드 템플릿을 수정한 다음 이전 파드 인스턴스를 삭제해 쉽게 교체할 수 있다.
 - rc는 파드가 없다면 새 인스턴스를 시작한다.
 - 새파드가 시작되는 동안 짧은 시간의 다운타임을 허용할 수 있다면 이가 가장 간단한 방법이다.

#### 9.1.2. 새 파드 기동과 이전파드 삭제 
 - 다운타임이 발생하지 않고, 한번에 여러버전의 app 실행하는 것을 지원하는 경우, 프로세스를 전환 해 새파드 모두 기동한 후 이전파드 삭제 가능, 잠시동안 두배의 파드가 뜨므로 리소스 필요

#### 한번에 이전버전에서 새버전으로 전환
 - 파드의 앞쪽에는 일반적으로 서비스를 배치한다, 새 버전을 실행하는 파드를 불러오는 동안, 서비스는 파드의 이전버전에 연결됨.
 - 새파드가 모두 실행됨과 동시에 레이블 셀렉터를 변경후, 서비스를 새파드로 전환 가능하다. 이거를 블루그린 디플로이먼트라고 한다.
 - 새버전이 바르게 동작하면 이전 rc를 삭제해 이전파드를 삭제할 수 있다.
```
 kubectl set selector 명령어를 사용해 서비스의 파드 셀렉터를 변경할 수 있다.
```

#### 롤링 업데이트 수행
 - 이전 Rc를 천천히 스케일 다운하고, 새 파드를 스케일업해 이를 수행가능하다.
 - 서비스의 파드 셀렉터에 이전파드와 새파드를 모두 포함하게 해 요청을 두 파드 세트로 보낼 수 있다.
 - 수동으로 하는것은 매우 어렵고 오류발생 쉽다.

### 9.2 rc로 자동 롤링 업데이트 수행
 - kubectl을 사용해 쉽게 가능하다, 그러나 이방법도 구식이 되었다.

#### 9.2.1. 애플리케이션의 초기 버전 실행
 - v1을 실행시킨다음, 서비스로 노출시킨다.
 - 미니쿠베를 사용하는경우 서비스의 노드포트를 사용해 app 요청가능
```
    minikube service --url kubia       
     while true; do curl http://192.168.64.2:30151; done
```

#### 9.2.3 더이상 롤링 업데이트를 사용하지 않는 이유
 - 1 저자 스스로 만든 오브젝트를 쿠버가 수정하는것을 좋아하지 않는다.
 - 2 롤링업데이트를 수행하는 모든단계는 kubectl 클라이언트다. 자세한 로깅을 확인할수있다.
 - 또한 나쁜이유는 그것이 실제명령을 나타냄, 앞에 서 보여진것은 레플리카 수를 변경하면 알아서 제거함. 이미지태그를 변경하면 새 이미지로 실행하는 새로운 파드료 교체

#### 9.3 애플리케이션을 선언적으로 업데이트하기 위한 디플로이먼트 사용
 - low level의 rc 또는 rs를 통해 수행하는 대신, 애플리케이션을 배포하고 선언적으로 업데이트하는 수준높은 리소스이다.
 - 디플로이먼트->레플리카셋->파드들 이렇게 관리된다
 - 왜 rs도 관리되어야할까? , 9.2에서 봤듯이 롤링업데이트를할때 rs도 새로생성되고 관리되어야한다

#### 9.3.1 디플로이먼트 생성
 - 디플로이먼트를 생성하는것은 rs와 다르지않다, 매니페스트를 생성하고 업데이트 수행방법을 정의하는 필드도있다.

```
kubectl create -f kubia-deployment-v1.yaml --record
# de를 생성할때는 무조건 --record를 포함시켜야한다, 이명령은 개정이력에 명령어를 기록해 나중에 유용하게 사용할 수 있다.
```

#### deploayment 롤아웃 상태 출력
```
kubectl rollout status deployment kubia
```
 - 결과에 따르면 디플로이먼트의 롤아웃이 성공적으로 수행됐으므로 파드 레플리카가 성공적으로 수행중이다.

#### 디플로이먼트가 rs를 생성하는 방법과 rs가 파드를 생성하는 방식 이해
 - 파드의 이름을 꼭 기록해두자
 - 파드 중간숫자는 무엇을 의미할까? 바로 팟템플릿의 해시값을 의미, 레플리카셋이 파드를 관리함 의
```
kubectl get replicasets
# rs의 이름 해시값이 파드와 똑같음
```

#### 서비스로 파드 액세스
 - rs에 의해 생성된 rs 세개는 지금 실행중이므로, 레이블 셀렉터와 일치하게 되므로 이전에 생성한 서비스를 사용해 엑섹스 가능하다
 - 지금까지는 deployment 사용 해야하는 이유 그닥 모르겠음
 - 업데이트 방법을 비교해면 분명해짐


#### 9.3.2 디플로이먼트 업데이트
 - 이전에는 kubectl rolling-update를 통해 터미널을열어두고 완료될때까지 기다려야만 했다.
 - 디플로이먼트 파드 템플릿에서 새이미지 태그를 참조해 시스템이 의도하는 상태가 될수있또록 kube에 맞기면 된다

#### 사용가능한 디플로이 전략
 - default 는 rolling Update다.
 - recreate 전략정도가 대안인데, rc의 파드 템플릿 수정 후, 기존의 모든 파드를 삭제한 뒤 새로운 파드를 만든다
 - recreate 는 새파드를 만들기전에 모든 파드를 삭제한다. 새버전을 시작하기전에 이전 버전을 완전히 중지해야하는 경우 사용 다운타임발생
 

#### 데모 목적으로 롤링업데이트 속도 느리게 하기 
```
kubectl patch deployment kubia -p '{"spec": {"minReadySeconds": 10}}'
# patch는 편집기를 켜지않고 속성한두개정도 수정하는데 좋다
```
 - 아까 while 명령어를 키고 롤업데이트를 시작해보자 그리고 이미지를 v2로 바꿔보자

```
kubectl set image deployment kubia nodejs=liksa/kubia:v2
```
#### 디플로이먼트의 놀라움 
- 디플로이먼트가 알아서 최신버전으로 업데이트했다!
```
kubectl get rs  
```
- 레플리카셋을 조회하면 기존 rs와 새 rs를 나란히 볼 수 있다.

#### 9.3.3 디플로이먼트 롤백
- 오류가 있는 v3 버전으로 배포해보
```
kubectl set image deployment kubia nodejs=luksa/kubia:v3
kubectl rollout undo deployment kubia 

```
- 레플리카셋 이살아있던걸 기어갛는가? 레플리카셋을 수동으로 삭제하면 롤백불가능하
- editionHistoryLimit 는 v1bet2 버전에서는 10이

```
# 리비전 보기
kubectl rollout history deployment kubia 
# 특정 리비전 코드확인
kubectl rollout history deployment kubia --revision=3
# 궁금증, 손으로 하다보면 오류가난다 예전 라이브니스 프로브니스 처럼 파드를 중지시키는것처럼 롤백을 자동적으로 하는것은?
# 특정버전으로 undo
kubectl rollout undo deployment kubia --to-revision=2
```

#### 롤링업데이트 전략의 maxSurge와 maxUnavailable 속성 소개
 - maxSurge : 디플로이먼트가 의도하는 레플리카보다 얼마나 많은 파드의 인스턴수수를 허용할지 결정 기본 25% 의도하는 레플리카수가 4로설정된경우 5개이상 파드가 실행되지 않음 백분율대신 값이 절대값일수 있음
 - maxUnavailable : 업데이트중에 레플리카수를 기준으로 사용할수 없는 파드 인스턴스수를 결정, 기본적으로 25% 레플리카 수의 75% 이하로 떨어지지 않아야한다, 백분율을 절대숫자로하면 내림됨

#### 9.3.5 롤아웃 프로세스 일시중지
 - v3에 대한좋지않은 경험을 한 후 수정하고 v4를 푸시했다고 가정, v2 옆에 v4 파드 하나를 실행하고, 일부사용자만 작동하는지 확인한다
 - 롤아웃 프로세스중에 배포를 완전중지 할수 있다.

```
kubectl set image deployment kubia nodejs=luksa/kubia:v4
kubectl rollout pause deployment kubia

```
 - 카나리 릴리스를 할 수 있다, 위험을 최소화 하는 기술.
 - 롤아웃 재개
```
kubectl rollout resume deployment kubia 
```

#### 잘모된 버전 롤아웃 방지
 - minReadySeconds 의 기능은 재미가 아니라 잘못된 버전으 롤아웃을 방지하는 것이다
 - 적절하게 구성된 레디니스 프로브와 적절한 minRedySeconds의 설저응로 쿠버는 v3를 배포하지 못하게 가능하다


#### 버전 v3가 완전롤아웃되는것을 방지하는 레디니스 프로브 정의
 - v3를 다시배포하지만 레디니스 프로브가 정의 되어야한다
 - 이미지를 변경하고 프로브를 한번에 추가하려면 kubectl apply명령어를 사용한다
```
kubectl apply -f kubia-deployment-v3-with-readinesscheck.yaml 
kubectl rollout status deployment kubia
# 결과를보면 하나의 파드가 생성돼있으므로 서비스가 호출돼야한다 확인해보자, 접근하지않는다 왜일까? 파드가 준비되지 않은것같다.
```
 - 레디니스 프로브니스가 매초마다 시작되므로, 다섯번째 요청부터 500을 반환하기때문에 실패하기 시작한다
 - 결과적으로 서비스의 엔드에서 파드가 제거된다
 - curl로 접근하지 못하는 이유다
 - 모든파들을 v3로 교체한것가괕은 큰 문제는 아니다.
 - #tip minReadySeconds를 정의하지않고 레디니스프로브만 설정하면, 모든 파드의 잘못된버전이 롤아웃된다. 잘 사용하자

#### 롤아웃 데드라인 설정
 - 기본적으로 롤아웃이 10분동안 진행되지않으면 실패한것으로 간주된다
 - 다음명령어로 조건을 확인해보자

```
kubectl describe deploy kubia 
```
 - 잘못된 롤아웃중지
```
kubectl rollout deployment kubia
kubectl rollout undo deployment kubia
```
